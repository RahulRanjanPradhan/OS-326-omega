                            +-------------------+
                            |   CS 326          |
                            |  PROJECT 1a       |
                            | DESIGN DOCUMENT   |
                            +-------------------+

 ---- GROUP ----
Yi Xu
Jie Gao
Wei Fang


---- PRELIMINARIES ----

None.


---- DATA STRUCTURES ----

**** thread.h ****

Added to struct thread:
    /* Members for implementing timer_sleep(). */
    struct semaphore sema;              //Semaphore used to lock this thread
                                        //when sleep.
    int64_t wakeup_time;                //Time that this thread should wake
                                        //up.
    struct list_elem sleep_list_elem;   // Element in sleep_list.


**** timer.c ****

Add a static member:
    /* List of processes in sleeping state, that is, processes
       should be be blocked until the wakeup_time of the processes. */
    static struct list sleep_list;



---- ALGORITHMS ----

Use semaphore to implement new thread_sleep() instead of busy waiting.
Each thread has new attribute: semaphore and wakeup_time.
When a thread need to sleep, call sema_down(), and add the thread to 
sleep_list. Timer_interrupt checks the sleep_list by wakeup_time to see if 
there are threads that need to be waken up. If so, use sema_up() to wake them 
up and then add them to ready_list.

Use priority schedule instead of round-robin.
Function compare_thread_priority() provide a way to compare the priority of 
two threads. Hence next_thread_to_run can sort the ready_list by priority by
compare_thread_priority and return the thread with highest priority.
Now when the scheduler picks next thread to run by next_thread_to_run,
then it will use the priority schdule.


---- SYNCHRONIZATION ----

Each thread has a semphore which is initialized with the value of 0. When the
thread need to sleep, using sema_down to block the thread, the value of
semaphore hence decrease to -1 and no other thread can enter the semaphore
until wakeup_time. So it will guarantee the thread sleeps for enough time.
At that time, timer_interrupt will find the thread, and it will using
sema_up to unblock it.


---- RATIONALE ----

The advantage of our design is that the timer_sleep can guarantee the thread
sleep for enough time using semaphore and wakeup-time.
And the scheduler will not pick the thread that should in sleep.
And unlike lock, semaphore can access by others, so that timer_interrupt
can wake the thread up after it had slept enough time.

On the other hand, the design is wasteful because each thread need to have
a semaphore. Actually, we think about use one semaphore to implement the
same fuction, but it will need to modified sema_down in synch.c, so we change
our design.


