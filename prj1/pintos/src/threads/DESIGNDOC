                            +-------------------+
                            |   CS 326          |
                            |  PROJECT 1a       |
                            | DESIGN DOCUMENT   |
                            +-------------------+

 ---- GROUP ----
Yi Xu
Jie Gao
Wei Fang

  
---- PRELIMINARIES ----
 
None.

 
---- DATA STRUCTURES ----

**** thread.h ****

Added to struct thread:
    /*Members for implementing timer_sleep(). */
    struct semaphore sema;             /* Semaphore used to lock this thread 
                                        when sleep. */
    int64_t wakeup_time;               /* Time that this thread should wake 
                                        up. */
    struct list_elem sleep_list_elem;  /* Element in sleep_list. */


**** timer.c ****

Add a static member:
    /* List of processes in sleeping state, that is, processes
       should be be blocked until the wakeup_time of the processes. */
    static struct list sleep_list;



---- ALGORITHMS ----

>> Briefly describe your implementation of thread_join() and how it
>> interacts with thread termination.

thread_join() finds the joined child on the thread's list of
children and waits for the child to exit by acquiring the child's
ready_to_die latch.  When thread_exit() is called, the thread
releases its ready_to_die latch, allowing the parent to continue.


**** thread.c ****

Added to init_thread()
    sema_init(&t->sema, 0);             /* Initialize semaphore to 0 for 
                                        timer_sleep(). */

Add a function compare_thread_priority():
    /* Compare threads by priority. Greater priority would run first. */
    bool compare_thread_priority (const struct list_elem *a,
                              const struct list_elem *b,
                              void *aux)
    {
      struct thread *t1 = list_entry (a, struct thread, elem);
      struct thread *t2 = list_entry (b, struct thread, elem);
      return t1->priority > t2->priority;
    }

Modify next_thread_to_run():
    static struct thread *
    next_thread_to_run (void) 
    {
      if (list_empty (&ready_list))
        return idle_thread;
      else
      {
        /* sort ready_list by priority first. */
        list_sort(&ready_list, compare_thread_priority, NULL);
        return list_entry (list_pop_front (&ready_list), struct thread, elem);
      }
    }

**** timer.c ****

Modify timer_init():
    void
    timer_init (void)
    {
      pit_configure_channel (0, 2, TIMER_FREQ);
      intr_register_ext (0x20, timer_interrupt, "8254 Timer");
      list_init (&sleep_list);
    }

Modify timer_sleep():
    void
    timer_sleep (int64_t ticks)
    {
      ASSERT (intr_get_level () == INTR_ON);
      intr_disable ();
      if (ticks > 0)
      {
        int64_t start = timer_ticks ();
        struct thread *t = thread_current();
        t->wakeup_time = start + ticks;
        
        list_push_back(&sleep_list, &t->sleep_list_elem);
        sema_down(&t->sema);
      }
      intr_enable();
    }

Modify timer_interrupt():
    static void
    timer_interrupt (struct intr_frame *args UNUSED)
    {
      ticks++;
      thread_tick ();

      struct list_elem *e;
      for (e = list_begin (&sleep_list); e != list_end (&sleep_list);)
      {
        struct thread *t = list_entry (e, struct thread, sleep_list_elem);
        if(timer_ticks() >= t->wakeup_time)
        {
          sema_up(&t->sema);
          e = list_remove(e);
        }
        else
        {
          e = list_next(e);
        }
      }
    }


---- SYNCHRONIZATION ----

>> Consider parent thread P with child thread C.  How do you ensure
>> proper synchronization and avoid race conditions when P calls wait(C)
>> before C exits?  After C exits?  How do you ensure that all resources
>> are freed in each case?  How about when P terminates without waiting,
>> before C exits?  After C exits?  Are there any special cases?

C waits in thread_exit() for P to die before it finishes its own
exit, using the can_die semaphore "down"ed by C and "up"ed by P as
it exits.  Regardless of whether whether C has terminated, there
is no race on wait(C), because C waits for P's permission before
it frees itself.

Regardless of whether P waits for C, P still "up"s C's can_die
semaphore when P dies, so C will always be freed.  (However,
freeing C's resources is delayed until P's death.)

The initial thread is a special case because it has no parent to
wait for it or to "up" its can_die semaphore.  Therefore, its
can_die semaphore is initialized to 1.

---- RATIONALE ----

>> Critique your design, pointing out advantages and disadvantages in
>> your design choices.

This design has the advantage of simplicity.  Encapsulating most
of the synchronization logic into a new "latch" structure
abstracts what little complexity there is into a separate layer,
making the design easier to reason about.  Also, all the new data
members are in `struct thread', with no need for any extra dynamic
allocation, etc., that would require extra management code.

On the other hand, this design is wasteful in that a child thread
cannot free itself before its parent has terminated.  A parent
thread that creates a large number of short-lived child threads
could unnecessarily exhaust kernel memory.  This is probably
acceptable for implementing kernel threads, but it may be a bad
idea for use with user processes because of the larger number of
resources that user processes tend to own.
