                            +-------------------+
                            |   CS 326          |
                            |  PROJECT 1a       |
                            | DESIGN DOCUMENT   |
                            +-------------------+

 ---- GROUP ----
Yi Xu
Jie Gao
Wei Fang


---- PRELIMINARIES ----

None.


---- DATA STRUCTURES ----

**** thread.h ****

Added to struct thread:
    /* Members for implementing timer_sleep(). */
    struct semaphore sema;              //Semaphore used to lock this thread
                                        //when sleep.
    int64_t wakeup_time;                //Time that this thread should wake
                                        //up.
    struct list_elem sleep_list_elem;   // Element in sleep_list.

Add a function to help insert thread to ready_list in order:
    /* Compare threads by priority so that can insert
    thread by priority.Greater priority would run first. */
    bool compare_thread_priority (const struct list_elem *,
                                const struct list_elem *,
                                void *);

Add a function to call scheduler :
    /* Do yield operation in interrupt or non-interrupt condition */
    void thread_super_yield (void);


**** timer.c ****

Add a static member:
    /* List of processes in sleeping state, that is, processes
       should be be blocked until the wakeup_time of the processes. */
    static struct list sleep_list;

**** synch.h ****

Add a function to help insert thread to waiters:
    /* Compare elem by priority. Greater priority would run first. */
    bool compare_thread_priority_in_sema (const struct list_elem *,
                                          const struct list_elem *,
                                          int *);

---- ALGORITHMS ----

**** Alarm clock ****

Use semaphore to implement new thread_sleep() instead of possible busy 
waiting. Each thread has two new attributes: semaphore and wakeup_time.
When a thread needs to sleep, call sema_down(), and add the thread to
sleep_list. The new timer_interrupt checks the sleep_list by
wakeup_time to see if there are threads that need to be woken up.
If so, use sema_up() to wake them up and then add them to ready_list.


**** Priority scheduler ****

According to the requirements of priority schedule, make these changes.

When a thread is added to the ready_list:
1. create a new thread
2. wake up a sleep thread
3. unblock a thread
4. yield the CPU
Use compare_thread_priority to keep all the threads in ready_list is listing
by decreasing priority.

Create a new method: thread_super_yield to call scheduler whether it is in
interrupt or not so that when a thread is added to the ready list that has a
higher priority than the current running thread, yield the processor 
immediately to the new thread.

Change the method thread_ticks to handle the case
1. When the first thread's priority in ready_list is equal to current
thread's: use round_robin.
2. When the first thread's priority in ready_list is less than current
thread's: make the thread_ticks to 0, so the scheduler will check 
#(TIME_SLICE) ticks later.

Also, when we use semaphore to block a thread, we make the insertion in the
order of decreasing priority to the list named waiter. We modified sema_up 
and cond_wait, then when threads are waiting for semaphore or condition 
variable, the highest priority waiting thread will always be woken up first.


---- SYNCHRONIZATION ----

Two synchronization ways:
1. Synchronous  : Every #(TIME_SLICE) ticks, timer_interrupt() will check if
                 there are threads need to be woken up.  And also do 
                 round-robin between the same priority thread.
2. Asynchronous : Whenever there is a potential higher priority thread added
                 to the ready_list, we will call thread_super_yield() to make
                 sure that the highest thread is in running state.


---- RATIONALE ----

**** Alarm clock ****

The advantage of our design is that the timer_sleep can guarantee the 
thread to sleep for the expected time using semaphore and wakeup-time.
And the scheduler will not pick the thread that should be in sleep state.
And unlike lock, semaphore can access by others, so that timer_interrupt
can go through the sleep_list and wake the thread up after it had slept 
enough time.

On the other hand, the design is wasteful because each thread need to have
a semaphore. Actually, we think about using one semaphore to implement the
same function, but it will need to modified sema_down in synch.c, so we 
changed our design.

**** Priority scheduler ****

Advantage: Enable priority scheduler that highest priority thread will be 
always in running state. If there are several highest priority threads, they 
will be scheduled in round-robin strategy. Highest priority thread will be 
the first one in every list(i.e. ready list, waiting list, sleep list). 
At first we compare the priority of the first one with current thread. If
the condition isn't matched, we don't call schedule() at all. With the new
function thread_super_yield(), we can handle in-interrupt and out-interrupt 
situations if a new thread comes.

Disadvantage: Not found yet.



